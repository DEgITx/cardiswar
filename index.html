<head>
<script src="/socket.io/socket.io.js"></script>
<script src="/phaser/phaser.js"></script>
<script src="/phaser-input/phaser-input.js"></script>
<style>
        html, body {
            overflow: hidden;
            width   : 100%;
            height  : 100%;
            margin  : 0;
            padding : 0;
        }

        canvas {
            width   : 100%;
            height  : 100%;
            /* touch-action: none; */
        }
    </style>
<script>
  var socket = io('http://localhost:8099');  
  
  window.addEventListener('DOMContentLoaded', function(){
      var joined = false;
	  var nickInput;
	  var players;
	  var player;
	  var map;
	  var currentTurn = null;
	  var playersCursor = {};
	  var mapGroup = null;
	  var game = new Phaser.Game(window.innerWidth, window.innerHeight, Phaser.AUTO, '', { preload: preload, create: create, update: update });
	  
	  var playerDoingMove = false;

function LightenDarkenColor(num, amt) {
    var r = (num >> 16) + amt;
 
    if (r > 255) r = 255;
    else if  (r < 0) r = 0;
 
    var b = ((num >> 8) & 0x00FF) + amt;
 
    if (b > 255) b = 255;
    else if  (b < 0) b = 0;
 
    var g = (num & 0x0000FF) + amt;
 
    if (g > 255) g = 255;
    else if (g < 0) g = 0;
 
    return (g | (b << 8) | (r << 16));
  
}
	  
	  function loadTexture(texture, callback)
	  {
					if(!game.cache.checkImageKey(texture))
					{
						var loader = new Phaser.Loader(game);
						loader.image(texture, texture)
						loader.onLoadComplete.addOnce(callback);
						loader.start();
					}
					else
					{
						callback();
					}
	  }
	  
	  var cardGroups = [];
	  function drawInventory()
	  {
			moneyText.text = player.money + "$";
			var oldCardX = 0;
			player.inventory.forEach(function(card, index){
				if(cardGroups[index] != null)
				{
					cardGroups[index].destroy();
					delete cardGroups[index];
				}
				var cardGroup = game.add.group();
				cardGroups[index] = cardGroup;
				var cardImage = game.add.sprite(32, 32, 'card');
				//cardGroup.create(32, 32, 'card');
				cardGroup.scale.set(0.3, 0.3);
				//cardGroup.scale.set(0.4, 0.4);
				
				var graphics = game.add.graphics(45, 53);
				cardGroup.add(graphics);
				graphics.beginFill(card.group.color, 1);
				graphics.drawRect(30, 30, 635, 925);
				
				cardGroup.add(cardImage);
				
				if(card.group.image.length > 0)
				{
					graphics = game.add.graphics(0, 0);
					graphics.beginFill(0xFFFFFF, 1);
					graphics.drawRect(75, 260, 635, 330);
					cardGroup.add(graphics);
				
					loadTexture(card.group.image, function(){
						var cardCoolImage = game.add.sprite(230, 260, card.group.image);
						cardCoolImage.width = 330;
						cardCoolImage.height = 330;
						cardGroup.add(cardCoolImage);
					});
				}
				
				graphics = game.add.graphics(45, 53);
				cardGroup.add(graphics);
				graphics.beginFill(LightenDarkenColor(card.group.color, 140), 1);
				graphics.drawRoundedRect(410, 60, 220, 120, 20);
				var costText = game.add.text(480, 133, card.cost, { fontSize: '64px', fill: '#000' });
				cardGroup.add(costText);
				
				graphics = game.add.graphics(45, 53);
				cardGroup.add(graphics);
				graphics.beginFill(LightenDarkenColor(card.group.color, 140), 1);
				graphics.drawCircle(110,120,100);
				var groupEffectText = game.add.text(134, 132, card.groupEffect, { fontSize: '64px', fill: '#000' });
				cardGroup.add(groupEffectText);
				
				
				card.penalty.forEach(function(penalty, i)
				{
					var graphics = game.add.graphics(45, 53);
					cardGroup.add(graphics);
					graphics.beginFill(LightenDarkenColor(card.group.color, 140), 1);
					graphics.drawRoundedRect(80, 580 + (i*70), 530, 50, 20);
					var penaltyText = game.add.text(135, 639 + (i*70), (card.currentPenalty == i ? '> ' : '') + 'штраф ' + (i+1) + ": " + penalty, { fontSize: '30px', fill: '#000' });
					cardGroup.add(penaltyText);
				});
				
				cardGroup.y = game.world.height - cardGroup.height;
				cardGroup.x = oldCardX + cardGroup.width;
				oldCardX = cardGroup.x;
			});
	  }
	  
	  var onlineGroup;
	  var onlineGroupTexts = {};
	  var onlineGroupTextsLastLength = 0;
	  function drawOnline()
	  {
		if(onlineGroupTextsLastLength > Object.keys(players).length)
		{
			onlineGroup.destroy();
			onlineGroup = null;
			onlineGroupTexts = {};
		}
		if(onlineGroup == null)
		{
			onlineGroup = game.add.group();
			onlineGroup.alpha = 0.7;
			var graphics = game.add.graphics(game.world.width - 260, 30);
			onlineGroup.add(graphics);
			graphics.beginFill(0x000000, 1);
			graphics.drawRoundedRect(0, 0, 250, 300, 25);
		}
		var i = 0;
		for(var id in players)
		{
			var text = (currentTurn != null && currentTurn.id == id ? '> ' : '') + players[id].nick + ' - ' + players[id].money + "$" + " - карт: " + players[id].inventory.length;
			if(onlineGroupTexts[id] == null)
			{
				onlineGroupTexts[id] = game.add.text(game.world.width - 245, 50 + i * 40, text, { fontSize: '18px', fill: '#fff' });
				onlineGroup.add(onlineGroupTexts[id]);
			}
			else
				onlineGroupTexts[id].text = text;
			
			i++;
		}
		onlineGroupTextsLastLength = Object.keys(players).length;
	  }
	  
	  function counterPlayerCordModMain(x, y, width, height, length, index)
	  {
			var power = Math.ceil(Math.sqrt(length));
			return {
				x: (x + (width / (power + 1)) * ((index % power) + 1)),
				y: (y + (height / ((length / power) + 1)) * (((index / power)|0) + 1))
			};
	  }
	  function counterPlayerCordMod(card, index)
	  {
			if(index.id != null)
				index = card.mapPlayers.indexOf(index.id);
			//alert(card.mapPlayers.length + ":" + index);
			return counterPlayerCordModMain(card.x, card.y, card.width, card.height, card.mapPlayers.length, index);
	  }

	  var playersColorsNum = 0;
	  var playersColorsAll = 6;
	  function drawMap()
	  {
		if(mapGroup != null)
		{
			mapGroup.destroy();
			mapGroup = null;
		}
		mapGroup = game.add.group();
		for(var i = 0; i < map.length; i++)
			{
				function cellImage(image, cell)
				{
					loadTexture(image, function(){
						var cardCoolImage = game.add.sprite(map[cell].x, map[cell].y, image);
						cardCoolImage.width = map[cell].width;
						cardCoolImage.height = map[cell].height;
						cardCoolImage.z = 0;
						mapGroup.add(cardCoolImage);
					});
				}
				
				if(map[i].image.length > 0)
				{
					cellImage(map[i].image, i);
				}
				else if(map[i].group != null && map[i].group.image.length > 0)
				{
					cellImage(map[i].group.image, i);
				}
				
				if(map[i].cost > 0)
				{
					var groupEffectText = game.add.text(map[i].x + map[i].width/2 - 23, map[i].y + map[i].height/2 - 10, map[i].cost, { fontSize: '20px', fill: '#000' });
					mapGroup.add(groupEffectText);
				}
				
				var line = game.add.graphics(0, 0);
				line.lineStyle(1, 0xDDDDDD, 1);
				line.drawRect(map[i].x, map[i].y, map[i].width, map[i].height);
				mapGroup.add(line);
			}
			playersColorsNum = 0;
			for(var i = 0; i < map.length; i++)
			{
				map[i].mapPlayers.forEach(function(gamer, index){
					var newCord = counterPlayerCordMod(map[i], index);
					
					var color = playersColorsNum + 1 < playersColorsAll ? playersColorsNum++ : (playersColorsNum = 0);
					playersCursor[gamer] = game.add.sprite(newCord.x, newCord.y, 'fishka_' + color);
					playersCursor[gamer].x -= playersCursor[gamer].width / 2;
					playersCursor[gamer].y -= playersCursor[gamer].height / 2;
					mapGroup.add(playersCursor[gamer]);
				});
			}
	  }
	  
	  socket.on('join', function (data) {
			nickInput.destroy();
			var moneyBag = game.add.sprite(0, game.world.height - 130, 'bag');
			moneyText = game.add.text(10, game.world.height - 70, '0$', { fontSize: '25px', fill: '#000' });
			
			stepButton = game.add.button(game.world.width - 100, game.world.height - 100, 'next', function(){
				if(!playerDoingMove)
					socket.emit('makestep');
			}, this, 2, 1, 0);
			stepButton.width = 80;
			stepButton.height = 80;
			
			buyButton = game.add.button(game.world.width  - 180, game.world.height - 100, 'buy', function(){
				socket.emit('buycard');
			}, this, 2, 1, 0);
			buyButton.width = 80;
			buyButton.height = 80;
	  
			players = data.map.players;
			player = data.player;
			map = data.map.map;
			console.log('Me with id ' + data.player.id + ' joined');
			console.log(map);
			
			drawInventory();
			drawOnline();
			drawMap();
			
			socket.on('joinplayer', function (data) {
				console.log('Player ' + data.player.id + ' join');
				map = data.map.map;
				players = data.map.players;
				drawMap();
				drawOnline();
			});
			
			socket.on('leftplayer', function (data) {
				console.log('Player ' + data.player.id + ' left');
				delete players[data.player.id];
				if(playersCursor[data.player.id] != null)
				{
					playersCursor[data.player.id].destroy();
					delete playersCursor[data.player.id];
				}
				drawOnline();
			});
			
			socket.on('makestep', function(data){
				map = data.map.map;
				players = data.map.players;
				if(data.player.id == player.id)
				{
					player = data.player;
				}
				playersCursor[data.player.id].movePoints = data.path;
				currentTurn = data.turn;
				playerDoingMove = true;
			});
			
			socket.on('buycard', function(data){
				players = data.players
				if(data.player.id == player.id)
				{
					player = data.player;
				}
				if(data.result)
				{
					drawInventory();
					drawOnline();
				}
			});
	  });
	  
		function preload() {
			game.load.image('background', 'images/background.jpg');
			
			game.load.image('card', 'images/card.png');
			game.load.image('card_in', 'images/cards/sun.png');
			
			game.load.image('next', 'images/next.png');
			game.load.image('buy', 'images/buy.png');
			game.load.image('bag', 'images/bag.png');
			
			game.load.image('fishka_0', 'images/fishka/fishka_red.png');
			game.load.image('fishka_1', 'images/fishka/fishka_purple.png');
			game.load.image('fishka_2', 'images/fishka/fishka_blue.png');
			game.load.image('fishka_3', 'images/fishka/fishka_orange.png');
			game.load.image('fishka_4', 'images/fishka/fishka_green.png');
			game.load.image('fishka_5', 'images/fishka/fishka_ocean.png');
		}
		
		function create() {	
			var background = game.add.image(0, 0, 'background');
			//var backgroundRatio = background.width/background.height
			
			game.add.plugin(Fabrique.Plugins.InputField);
			nickInput = game.add.inputField(game.world.centerX, game.world.centerY, {
				font: '36px Arial',
				fill: '#666666',
				fontWeight: 'bold',
				width: 350,
				height: 45,
				padding: 8,
				borderWidth: 1,
				borderColor: '#000',
				borderRadius: 6,
				placeHolder: 'Your Nick',
			});
			nickInput.x -= nickInput.width / 2;
			nickInput.y -= nickInput.height / 2;
			
			game.input.keyboard.onDownCallback = function(e) {
				if(e.keyCode == 13 && !joined && nickInput.text.text.length > 0)
				{
					joined = true;
					socket.emit('join', { nick: nickInput.text.text});
				}
			};
		}

		var waitPlayerCursorOnPoint;
		function update() {
			if(playerDoingMove)
			{
				var findMovePoint = false;
				for(var id in playersCursor)
				{
					if(playersCursor[id].movePoints != null && playersCursor[id].movePoints.length > 0)
					{
						findMovePoint = true;
						var point = playersCursor[id].movePoints[0];
						// Изменяем расположение курсора для последней точки на реальное
						var movePoint = {
							x: map[point].x + map[point].width / 2,
							y: map[point].y + map[point].height / 2
						};
						if(playersCursor[id].movePoints.length == 1)
						{
							movePoint = counterPlayerCordMod(map[point], players[id]);
						}
						movePoint.x -= playersCursor[id].width / 2;
						movePoint.y -= playersCursor[id].height / 2;
						game.world.bringToTop(playersCursor[id]);
						if(playersCursor[id].x - movePoint.x > 0)
						{
							playersCursor[id].x -= 3;
						}
						
						if(-(playersCursor[id].x - movePoint.x) > 0)
						{
							playersCursor[id].x += 3;
						}
						
						if(playersCursor[id].y - movePoint.y > 0)
						{
							playersCursor[id].y -= 3;
						}
						
						if(-(playersCursor[id].y - movePoint.y) > 0)
						{
							playersCursor[id].y += 3;
						}
						if(Math.abs(playersCursor[id].x - movePoint.x) < 3 && Math.abs(playersCursor[id].y - movePoint.y) < 3)
						{
							playersCursor[id].movePoints.shift();
						}
					}
				}
				if(!findMovePoint)
				{
					drawInventory();
					drawOnline();
					playerDoingMove = false;
				}
			}
		
			
		}

  });
</script>
</head>